'''Django предоставляет несколько функций для простой реализации собственного тега:
   simple_tag – обрабатывает данные и возвращает строку;
   inclusion_tag – обрабатывает данные и возвращает сформированный фрагмент шаблона.'''

from django import template
from ..models import Post
from django.db.models import Count

register = template.Library() # Для регистрации тега каждый модуль с функциями тегов
                              # должен определять переменную register;
                              # переменная является объектом класса template.Library
                              # и используется для регистрации пользовательских тегов и фильтров
                              # в системе

@register.simple_tag
def total_posts(): # тег total_posts в виде функции обернут в декоратор @register.simple_tag
                   # для регистрации нового тега;
                   # Django будет использовать название функции total_posts в качестве названия тега.
                   # Также можно в явном виде указать имя для обращения к тегу из шаблонов;
                   # для этого достаточно передать в декоратор аргумент name:
                   # @register.simple_tag(name='my_tag')
    '''шаблонный тег: возвращает 
    количество опубликованных в блоге статей'''
    return Post.published.count()


@register.inclusion_tag('blog/post/latest_posts.html') # регистрируем тег с помощью декоратора
                                                       # @register.inclusion_tag и указываем
                                                       # шаблон, который будет использоваться для
                                                       # формирования HTML
def show_latest_posts(count=5): # Функция будет принимать один дополнительный аргумент – count,
                                # определяет количество статей для отображения;
                                # зададим значение по умолчанию 5;
    '''тег для добавления последних статей блога на боковую панель'''
    latest_posts = Post.published.order_by('-publish')[:count] # используем count для ограничения результата запроса
    return {'latest_posts': latest_posts} # функция тега возвращает словарь переменных вместо простого значения;
                                          # инклюзивные теги должны возвращать только словари контекста,
                                          # который затем будет использован для формирования HTML-шаблона.
                                          # Чтобы задать любое другое количество статей, например 3, то
                                          # используестя запись: {% show_latest_posts 3 %}


@register.simple_tag
def get_most_commented_posts(count=5):
    '''шаблонный тег для отображения статей с наибольшим количеством комментариев'''
    # формируем QuerySet, используя метод annotate() для добавления к каждой статье количества ее комментариев
    # Аннотации, указанные с помощью ключевых аргументов, будут использовать ключевое слово в качестве псевдонима для аннотации. 
    # Для анонимных аргументов будет создан псевдоним, основанный на имени агрегатной функции и агрегируемого поля модели. 
    # Только агрегатные выражения, которые ссылаются на одно поле, могут быть анонимными аргументами.
    # Count используется в качестве функции агрегации, которая вычисляет
    # количество комментариев total_comments для каждого объекта Post
    return Post.published.annotate(total_comments=Count('comments'))\
                         .order_by('-total_comments')[:count] # сортируем QuerySet по созданному полю total_comments в порядке убывания с ограничением count


'''Примечание: После добавления нового модуля с тегами необходимо перезагрузить сервер для раз-
работки, чтобы Django зарегистрировал определенные теги и фильтры и мы могли ис-
пользовать их в HTML-шаблонах.'''
